I"/v<p>Se você ja escreveu alguma equação matemática(x = a + 1), você sabe bem que o “=” não quer dizer atribuição (assignment), na verdade quer dizer que você está dizendo que a expressão x tem o mesmo valor que a expressão “a + 1”. Sabendo o valor de x facilmente você saberia o valor de a e vice-versa. Joe Armstrong falava que em algum momento você teve que desaprender o significado algébrico do “=” quando você aprendeu a sua primeira linguagem de programação. </p>

<p>Com Elixir você vai reaprender ou pela menos desaprender a forma errada e voltar a usar a forma algébrica, pelo menos em partes.</p>

<p>Este pequeno artigo está dividido em sete partes:</p>
<ul>
  <li>O operador de Match (=)</li>
  <li>Match com tuplas</li>
  <li>Match com listas</li>
  <li>Ignorando variáveis com underscore</li>
  <li>O operador Pin(^)</li>
  <li>Match em retorno de funções</li>
  <li>Match em parâmetros de funções</li>
</ul>

<h1 id="o-operador-de-match">O operador de Match (=)</h1>
<p>Quando começamos com Elixir esse operador geralmente causa muita confusão porque estamos acostumados a pensar nele como uma operador de atribuição de valor. Por isso de vez em quando podemos cair em algum problema onde não sabemos o motivo pelo qual algo aconteceu, e esse problema pode ter sido causado por falta de conhecimento em como o pattern matching e esse operador “=” funciona.
Para explicar melhor vamos à alguns exemplos:</p>
<h3 id="isto-é-um-match">Isto é um match</h3>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Pode parecer que estamos fazendo uma atribuição de um valor 1 para a variável “a” e é isto que pode causar muita confusão porque na verdade não estamos. O que estamos fazendo é um match do valor 1 com a variàvel “a” que agora estará “bound” à esse valor. 
Ahh Thiago mas qual é a diferença entre isso e o que eu faço no Ruby ou no Java. 
Em termos práticos, no momento, não há diferença mas o que você deve ter em mente é que o que está acontecendo aqui é que a expressão “a = 1” é equivalente à uma equação onde o Elixir combina os dois valores e os compara, se tudo der certo ele retorna o resultado dessa equação. Se você rodar isso no console verá impresso o valor final. No caso: 1.
Uma das formas de testar isso é testar o match contrário:
Isto é um match também</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></div></div>
<p>O que está expressão vai imprimir é 1.</p>

<p>Mas se testarmos:</p>
<h3 id="isto-é-um-match-também-porém-vai-dar-erro">Isto é um match também porém vai dar erro</h3>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></div></div>

<p>E o erro que teremos é do tipo:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Isso porque, préviamente, tínhamos feito um “bind” da variável a com o valor 1.
Pode não parecer muita coisa pra você agora mas até o final do artigo você vai ficar igual à esse cara aqui:
Ou pode ficar que nem esse cara aqui, você decide:
O poder do pattern matching reside no fato de que com ele podemos procurar e/ou verificar match desde padrões simples até estruturas de dados e funções. Continue lendo e não desista que vai dar tudo certo. :))</p>

<h1 id="match-comtuplas">Match com tuplas</h1>
<p>Como eu disse anteriormente o pattern matching pode ser aplicado em vários tipos de estrutura de dados como em tuplas:</p>
<h3 id="isto-é-um-match-também">Isto é um match também</h3>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">}</span>
</code></pre></div></div>
<p>Nesse caso estamos fazendo um match no pattern “{a, b}” o que faz com que as variáveis a e b sejam bindadas aos valores 20 e 50.</p>

<p>Se tentarmos agora modificar o valor da variável a usando o mesmo pattern {a, b} não teria problema.</p>
<h3 id="isto-é-um-rebound-da-variável-a-para-o-novo-valor">Isto é um rebound da variável a para o novo valor.</h3>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">}</span>
</code></pre></div></div>

<p>Nós ainda poderíamos mudar o valor da variável a:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">200</span>
<span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">50</span><span class="p">}</span>
</code></pre></div></div>
<p>Mais uma vez isso é um rebound. Estamos bindando a variável a um novo valor.</p>

<h1 id="match-comlistas">Match com Listas</h1>
<p>Podemos fazer algumas coisas interessantes com o pattern matching usando listas.
Exemplo:</p>
<h3 id="este-exemplo-imprime-1-2-3">Este exemplo imprime [1, 2, 3]</h3>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1"># Aqui estamos imprimindo a variavel b que recebeu o valor do segundo item da lista (list)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">b</span>
<span class="o">&gt;</span> <span class="mi">2</span>
</code></pre></div></div>
<p>Neste exemplo nós substituímos o segundo elemento pela letra “b” fazendo assim com que o segundo elemento da lista “list” fosse bindado à variável b. Quando tentarmos imprimir o valor de b teríamos o 2 como resultado.</p>

<p>Uma lista em elixir é constituída por duas partes. A cabeça e o rabo (é engraçado escrever em português mas é a tradução correta). Mas em ingles como são boa parte das linguagens de programação é chamado head | tail.
O operador |(pipe) serve para que possamos separar o head do tail em uma lista.
Exemplo:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span>
<span class="n">head</span>
<span class="o">&gt;</span> <span class="mi">1</span>
<span class="n">tail</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Outra coisa que podemos fazer também é associar aos valores algumas variáveis como:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span>
<span class="n">a</span>
<span class="o">&gt;</span> <span class="mi">1</span>
<span class="n">b</span>
<span class="o">&gt;</span> <span class="mi">2</span>
<span class="o">...</span>
</code></pre></div></div>

<p>Agora você já começa a ver um pouco mais sobre o poder do pattern matching. Estamos associando à variáveis, valores dentro de uma lista.
Neste caso não podemos fazer um match de tamanhos diferentes ou valores diferentes:</p>
<h3 id="isso-dá-erro-de-match">Isso dá erro de match</h3>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span>
</code></pre></div></div>
<p>Dá erro porque o valor 5 não é igual ao valor do último item da lista.
Isso daria erro:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span>
<span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">list</span>
</code></pre></div></div>

<p>Porque estaríamos fazendo um rebound das variáveis e bindando um novo valor para a variável d.
Ignorando valores com underscore
O que acontece quando não queremos associar um valor à nada. Simplesmente não nos interessamos por um valor em uma lista ou em uma tupla por exemplo. 
Para isso usamos o underscore. Tudo com underscore do lado esquerdo em um pattern matching é desconsiderado.</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">_</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="s2">"Thiago"</span><span class="p">}</span>
<span class="n">a</span>
<span class="o">&gt;</span> <span class="mi">30</span>
</code></pre></div></div>
<p>O valor “Thiago” nunca será associado a nada já que foi ignorado quando usamos o <code class="highlighter-rouge">_</code> underscore. Se usarmos assim:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">_name</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="s2">"Thiago"</span><span class="p">}</span>
<span class="n">a</span>
<span class="o">&gt;</span> <span class="mi">30</span>
</code></pre></div></div>

<p>O valor “Thiago” também seria ignorado. Porém ele não é. O Elixir deixa você usar a variável já que é um named variable porém lança um warning:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">warning:</span> <span class="n">the</span> <span class="n">underscored</span> <span class="n">variable</span> <span class="s2">"_name"</span> <span class="n">is</span> <span class="n">used</span> <span class="k">after</span> <span class="n">being</span> <span class="n">set</span><span class="o">.</span> <span class="no">A</span> <span class="n">leading</span> <span class="n">underscore</span> <span class="n">indicates</span> <span class="n">that</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">should</span> <span class="n">be</span> <span class="n">ignored</span><span class="o">.</span> <span class="no">If</span> <span class="n">this</span> <span class="n">is</span> <span class="n">intended</span> <span class="n">please</span> <span class="n">rename</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">remove</span> <span class="n">the</span> <span class="n">underscore</span>
</code></pre></div></div>

<p>Então para todos os sentidos não use underscore se quiser usar uma variável. Pra quem vem de outras linguagens pode achar estranho já que em outras linguagens poderíamos usar uma variável com underscore no início para indicar que ela não sera usado ou que ela é private.
Em elixir se não se importar com um valor mas precisar fazer o match use o underscore sozinho.</p>

<h1 id="o-operadorpin">O operador ^(pin)</h1>

<p>Vamos supor que você tem:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div>
<p>Se você fizer:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
</code></pre></div></div>
<p>Sua variável “x” será setada para o valor 20. Mas você pode simplesmente querer verificar o matching de x com o valor 20 ao invés de fazer um rebind.
Nesse caso você deve usar o operador pin(^):</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">^</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
<span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value:</span> <span class="mi">20</span>
</code></pre></div></div>

<p>O operador pin serve para que você faça o matching com uma variável que já tem um valor sem que ocorra o rebind da variável, ou seja, sem que ela mude de valor.</p>

<h1 id="pattern-matching-emfunções">Pattern Matching em Funções</h1>

<p>É aqui que você, provavelmente vai fazer um bom uso do pattern matching em elixir. Veja isso:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">hello</span><span class="p">(</span><span class="ss">:bob</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="s2">"Hi My dear friend Bob"</span>
<span class="k">def</span> <span class="n">hello</span><span class="p">(</span><span class="ss">:mary</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="s2">"Hi my lovely wife Mary"</span>
<span class="k">def</span> <span class="n">hello</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="s2">"Hi </span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>Vejam que em outras linguagens teríamos que ter condicionais para que esse código pudesse ser executado corretamente, no mínimo uma lógica que nem de longe seria tão simples quanto a solução acima. 
O que está acontecendo aqui?
Quando chamamos o método “hello” passando o valor “:bob”, Elixir, através do uso de pattern matching, vai chamar a função “hello” onde o valor :bob vai fazer matching com a variável declarada :bob e vai achar a função própria.
Se chamarmos o método “hello” passando “Ana” o matching não ocorrerá e a função encontrada será a terceira.
Vamos agora ver um matching mais sutíl:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyList</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">length</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">length</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">defp</span> <span class="n">length</span><span class="p">([],</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">count</span>
  <span class="k">end</span>
  <span class="k">defp</span> <span class="n">length</span><span class="p">([</span><span class="n">_</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">length</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<p>Nesse caso iremos chamar “MyList.length([1, 2, 3])” vejamos que temos um método publico “length” e dois métodos privados. Método privados são declarados com “defp”. Da primeira vez que chamarmos o método público “length” ele irá chamar qual dos dois métodos privados abaixo dele? Conseguiu adivinhar? Isso é pattern matching em ação com esteróides. 
O primeiro método “length”,</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defp</span> <span class="n">length</span><span class="p">([],</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">count</span>
<span class="k">end</span>
</code></pre></div></div>
<p>faz matching com uma lista vazia e um outro valor que pode ser um número. 
O segundo método:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defp</span> <span class="n">length</span><span class="p">([</span><span class="n">_</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">count</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">length</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>
<p>espera que a lista contenha um head que ele não se importa e um tail e mais uma variável que pode ser um número também chamada count.</p>

<p>Então, quando chamarmos o método length público ele chamará pela primeira vez o método que espera a lista com itens e este método fará uma chamada recursiva sempre pegando o “tail” da lista e incrementando o “count” até que a lista fique vazia e seja feito um matching com a função que espera uma lista vazia. E esta função, por sua vez, retorna o count apenas.
Pattern matching, como você pode ver, é uma ferramenta muito poderosa em Elixir. Mas ela ainda é usada de outra forma com funções, ela é muito usada no retorno das funções.</p>

<h1 id="match-com-retorno-defunções">Match com retorno de funções</h1>
<p>Como a pattern matching é uma ferramenta tão poderosa, convencionou-se em Elixir que as funções retornassem não só valores, como também, em muitas vezes, como tuplas. Algo muito comum em elixir é ver esse tipo de código:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">create</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">%{</span><span class="s2">"user"</span> <span class="o">=&gt;</span> <span class="n">user_params</span><span class="p">})</span> <span class="k">do</span>
  <span class="k">case</span> <span class="no">Accounts</span><span class="o">.</span><span class="n">create_user</span><span class="p">(</span><span class="n">user_params</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="n">conn</span>
        <span class="o">|&gt;</span> <span class="n">put_flash</span><span class="p">(</span><span class="ss">:info</span><span class="p">,</span> <span class="s2">"User created successfully."</span><span class="p">)</span>
        <span class="o">|&gt;</span> <span class="n">redirect</span><span class="p">(</span><span class="ss">to:</span> <span class="no">Routes</span><span class="o">.</span><span class="n">user_path</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="ss">:show</span><span class="p">,</span> <span class="n">user</span><span class="p">))</span>
    <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="p">%</span><span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span><span class="p">{}</span> <span class="o">=</span> <span class="n">changeset</span><span class="p">}</span> <span class="o">-&gt;</span>
      <span class="n">render</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">"new.html"</span><span class="p">,</span> <span class="ss">changeset:</span> <span class="n">changeset</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Veja que nesse caso a função “create_user” do módulo “Accounts” pode retornar dois tipos de tuplas, uma com o valor :ok e um user e outra com o valor :error e um struct do tipo “Ecto.Changeset”. O que fazemos, normalmente, é fazer o pattern matching com o retorno do método “create_user” e executar a ação apropriada. Vejam como é poderoso o pattern matching e como ele é extensamente usado pela linguagem.
Um último tópico que quero mostrar é como é possível extrair apenas as variáveis que nos interessam em um struct, map ou usar parâmetros nomeados, quando passamos parâmetros em uma função.
Exemplo 1: (Usando pattern match em uma variável de um struct e pegando todo o struct através de outra variável)</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyModule</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">get_keys</span><span class="p">(%{</span><span class="ss">name:</span> <span class="s1">'Thiago'</span><span class="p">}</span> <span class="o">=</span> <span class="n">map</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Map</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">map</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Podemos usar:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MyModule</span><span class="o">.</span><span class="n">get_keys</span><span class="p">(%{</span><span class="ss">name:</span> <span class="s1">'bob'</span><span class="p">,</span> <span class="ss">last_name:</span> <span class="s1">'Ramos'</span><span class="p">})</span>
<span class="o">**</span> <span class="p">(</span><span class="no">FunctionClauseError</span><span class="p">)</span> <span class="n">no</span> <span class="n">function</span> <span class="n">clause</span> <span class="n">matching</span> <span class="ow">in</span> <span class="no">MyModule</span><span class="o">.</span><span class="n">get_keys</span><span class="o">/</span><span class="mi">1</span>
<span class="no">The</span> <span class="n">following</span> <span class="n">arguments</span> <span class="n">were</span> <span class="n">given</span> <span class="n">to</span> <span class="no">MyModule</span><span class="o">.</span><span class="n">get_keys</span><span class="o">/</span><span class="mi">1</span><span class="p">:</span>
<span class="c1"># 1</span>
 <span class="p">%{</span><span class="ss">last_name:</span> <span class="s1">'Ramos'</span><span class="p">,</span> <span class="ss">name:</span> <span class="s1">'Bob'</span><span class="p">}</span>
<span class="ss">iex:</span><span class="mi">4</span><span class="p">:</span> <span class="no">MyModule</span><span class="o">.</span><span class="n">get_keys</span><span class="o">/</span><span class="mi">1</span>
</code></pre></div></div>
<p>Isso acontece porque o matching entre a variável “name” e o valor falharam quando chamamos a função “get_keys” do módulo “MyModule”.</p>

<p>Se quisermos usar a variável name dentro do método sem precisar pegar dentro do map poderemos fazer da seguinte forma:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">test</span><span class="p">(%{</span><span class="ss">name:</span> <span class="n">name</span><span class="p">}</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">name:</span> <span class="n">_</span><span class="p">})</span> <span class="k">do</span>
  <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="n">name</span>
<span class="k">end</span>
</code></pre></div></div>
<p>Nesse caso poderemos chamar:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span><span class="p">(%{</span><span class="ss">name:</span> <span class="s2">"Carlos"</span><span class="p">,</span> <span class="ss">age:</span> <span class="mi">25</span><span class="p">})</span>
<span class="no">Carlos</span>
<span class="ss">:ok</span>
</code></pre></div></div>

<p>Isso pode ser feito para vários tipos de estrutura de dados e inclusive nós usamos no exemplo de recursão.
Como vocês podem ver, Pattern Matching é uma das ferramentas mais importantes em Elixir e é muito importante que você domine bem para que possa se adequar mais facilmente ao idioma da linguagem. Além, é claro, de entender bem como funciona o paradigma funcional.
Espero que tenham gostado e se quiserem, me sigam nas redes sociais:
Instagram: @thiagoramosal</p>

<ul>
  <li>Youtube: <a href="https://www.youtube.com/thiagoramosal">Meu canal no Youtube</a></li>
  <li>Twitter: <a href="https://twitter.com/thramosal">@thramosal</a></li>
</ul>

<p>Se você quer ler mais sobre Elixir eu recomendo este site onde o autor está documentando todo o seu aprendizado com a linguagem:
<a href="https://inquisitivedeveloper.com/tag/lwm-elixir/">https://inquisitivedeveloper.com/tag/lwm-elixir/</a></p>

<p>Até a próxima.</p>
:ET